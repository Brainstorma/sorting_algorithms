# 0x1B. C - Sorting algorithms & Big O

Welcome to 0x1B. C - Sorting algorithms & Big O, a project to help you develop an understanding of sorting algorithms and measure their performance with Big O notation. In this project, you will learn how to implement and analyze the performance of different sorting algorithms in C.

## Table of Contents

1. [Introduction](#Introduction)
2. [Prerequisites](#Prerequisites)
3. [Installation](#Installation)
4. [Task 0 - Selecting the sorting algorithm](#Task0)
5. [Task 1 - Big O Notation](#Task1)
6. [Task 2 - Bubble Sort](#Task2)
7. [Task 3 - Insertion Sort](#Task3)
8. [Task 4 - Selection Sort](#Task4)
9. [Task 5 - Shell Sort](#Task5)
10. [Task 6 - Cocktail Sort](#Task6)
11. [Task 7 - Counting Sort](#Task7)
12. [Task 8 - Merge Sort](#Task8)
13. [Task 9 - Quick Sort](#Task9)
14. [Task 10 - Radix Sort](#Task10)
15. [Conclusion](#Conclusion)
16. [Questions](#Questions)

## Introduction

Sorting algorithms are an important part of computer science, as they allow data to be organized in a specific order. There are many different sorting algorithms, each with its own strengths and weaknesses. In this project, you will learn about the most commonly used sorting algorithms, their implementations in C, and their performance measured with Big O notation.

## Prerequisites

Before you begin, you should be familiar with basic concepts of the C programming language, including data types, functions, loops, and conditionals. You should also have a basic understanding of algebra, particularly logarithms and exponents.

## Installation

To start this project, you need to have a C compiler installed on your computer. You can use any C compiler, but for this project, we recommend using [GCC](https://gcc.gnu.org/). In addition, you need to create a directory for your project and create a Makefile with the commands to compile your project.

## Task 0 - Selecting the sorting algorithm 

The first step in this project is to select the sorting algorithm you will use for each of the tasks. Your choice of sorting algorithm should be based on its performance, as measured by its Big O notation. For each task, select the sorting algorithm that has the best performance for the type of data you are sorting.

## Task 1 - Big O Notation 

In this task, you will learn about Big O notation, which is a way to measure the performance of an algorithm. An algorithm's Big O notation is a representation of its time complexity, which is a measure of how long an algorithm takes to complete a task. You will use Big O notation to compare the performance of the different sorting algorithms.

## Task 2 - Bubble Sort

Bubble Sort is a sorting algorithm that compares adjacent elements and swaps them if they are out of order. It is known as an inefficient algorithm, as it can take a long time to sort a large set of data. 

## Task 3 - Insertion Sort

Insertion Sort is similar to Bubble Sort, as it also compares adjacent elements and swaps them if they are out of order. However, it is much more efficient than Bubble Sort, as it only considers elements that have not yet been sorted.

## Task 4 - Selection Sort

Selection Sort is another comparison-based sorting algorithm. It consists of finding the smallest element in the array and placing it at the beginning of the array. The process is then repeated for the remaining elements. 

## Task 5 - Shell Sort

Shell Sort is an optimization of Insertion Sort. It works by comparing elements that are a certain distance away from each other, instead of adjacent elements. This makes it more efficient than Insertion Sort, as it reduces the number of comparisons.

## Task 6 - Cocktail Sort

Cocktail Sort is an optimized version of Bubble Sort. It works by comparing adjacent elements and swapping them if they are out of order. However, it is much more efficient than Bubble Sort, as it only considers elements that have not yet been sorted.

## Task 7 - Counting Sort

Counting Sort is a sorting algorithm that works by counting the number of occurrences of each element in an array. It is much more efficient than comparison-based sorting algorithms, as it does not require any comparison of elements.

## Task 8 - Merge Sort

Merge Sort is a sorting algorithm that works by dividing the data into smaller subarrays and then merging them back together in a specific order. It is much more efficient than comparison-based sorting algorithms, as it does not require any comparison of elements. 

## Task 9 - Quick Sort

Quick Sort is a sorting algorithm that is based on the divide-and-conquer principle. It works by dividing a large array into smaller subarrays and then sorting each subarray. It is much more efficient than comparison-based sorting algorithms, as it does not require any comparison of elements.

## Task 10 - Radix Sort

Radix Sort is a sorting algorithm that works by sorting elements based on their individual digits or characters. It is much more efficient than comparison-based sorting algorithms, as it does not require any comparison of elements. 

## Conclusion 

In this project, you have learned about different sorting algorithms and how to analyze their performance using Big O notation. You have also implemented the algorithms in C and compared their performance. We hope that this project has helped you gain a better understanding of sorting algorithms and Big O notation, and that you can apply what you have learned in your own projects.

## Questions

If you have any questions, feel free to reach out. I will be more than happy to help you out.
